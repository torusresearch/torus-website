<!doctype html>
<html>
<head>
    <title>Torus Demo</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <script id="facebook-jssdk" src="https://connect.facebook.net/en_US/sdk.js"></script> -->
    <link rel="shortcut icon" href="images/favicon.png">
    <script src="https://apis.google.com/js/platform.js"></script>
    <meta name="google-signin-client_id" content="876733105116-i0hj3s53qiio5k95prpfmj0hp0gmgtor.apps.googleusercontent.com">
    <script src="./bn.js"></script>
    <script src="./elliptic.min.js"></script>
    <script src="./buffer.min.js"></script>
</head>

<body style="margin: 0px">
<div id="googleAuthBtn" style="height: 20px; width: 20px;"></div>
<script>
    var googleUser = {};
    var startApp = function() {
      gapi.load('auth2', function(){
      // Retrieve the singleton for the GoogleAuth library and set up the client.
      auth2 = gapi.auth2.init({
        client_id: '876733105116-i0hj3s53qiio5k95prpfmj0hp0gmgtor.apps.googleusercontent.com'
        // Request scopes in addition to 'profile' and 'email'
        //scope: 'additional_scope'
      });
      attachSignin(document.getElementById('googleAuthBtn'));
      });
    }

    function attachSignin(element) {
      console.log(element.id);
      auth2.attachClickHandler(element, {},
      function(googleUser) {
        console.log("GOOGLE USER: ", googleUser)
        var profile = googleUser.getBasicProfile();
            // console.log(googleUser)
            console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
            console.log('Name: ' + profile.getName());
            console.log('Image URL: ' + profile.getImageUrl());
            console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present.
            localStorage.setItem('id_token', googleUser.getAuthResponse().id_token)
            localStorage.setItem('email', profile.getEmail())
            gapi.auth2.getAuthInstance().disconnect().then(function () {
                window.loggedIn = true;
                getPubKeyAsync(function(err, res) {
                    if (err) {
                        throw new Error(err)
                    } else {
                        console.log('New private key assigned to user at address ', res)
                        retrieveShares()
                        updateWidgetDetails(res)
                    }
                })
            })
      }, function(error) {
        alert(JSON.stringify(error, undefined, 2));
      });
    }

    function eventFire(el, etype){
      if (el.fireEvent) {
        el.fireEvent('on' + etype);
      } else {
        var evObj = window.document.createEvent('Events');
        evObj.initEvent(etype, true, false);
        el.dispatchEvent(evObj);
      }
    }

    if (location.protocol != 'https:') {
        location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }
    function getEmail() {
        if (localStorage.getItem('email')) {
            return localStorage.getItem('email')
        } else {
            throw new Error('not signed in')
        }
    }

    function getPubKeyAsync(cb) {

        var endpoints = [
            "https://dkg1.tetrator.us/jrpc",
            "https://dkg2.tetrator.us/jrpc",
            "https://dkg3.tetrator.us/jrpc",
            "https://dkg4.tetrator.us/jrpc",
            "https://dkg5.tetrator.us/jrpc"
        ]

        var promiseArr = []
        var shares = []

        for (var i = 0; i < endpoints.length; i++) {
            var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'SecretAssign',
                    id: 10,
                    params: {
                        email: getEmail()
                    }
                })
            }).then(res => res.json())
            .then(res => shares.push(res))
            .catch(err => {
                console.error(err)
            })
            promiseArr.push(p)
        }

        Promise.all(promiseArr).then(function() {
            try {
                console.log('completed')
                console.log(shares)
                var points = shares.map(share => {
                    return ec.keyFromPublic({
                        x: share.result.PubShareX,
                        y: share.result.PubShareY
                    }).pub
                })
                var pubk = points.reduce((acc, item) => {
                    if (acc) {
                        return acc.add(item)
                    } else {
                        return item
                    }
                })
                console.log(pubk.encode('hex'))
                var publicKey = pubk.encode('hex').slice(2);
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38);
                console.log(ethAddress)
                cb(null, ethAddress)
            } catch (err) {
                cb(err, null)
            }
        })
    }
</script>
<script>
      </script>
      <script>
        var Elliptic = elliptic.ec
        var ec = new Elliptic('secp256k1')

        function updateWidgetDetails(ethAddress) {
            console.log('updating widget details')
            var checkSumAddress = window.web3.utils.toChecksumAddress(ethAddress)
            window.web3.eth.getBalance(checkSumAddress).then(result => {
                var accountBalance = Number(window.web3.utils.fromWei(result));
                var accountBalanceContent = accountBalance.toFixed(4) + " ETH";
                window.connectionStream.write({name: "widget", data: {
                    ethAddress,
                    balance: accountBalanceContent,
                    email: localStorage.getItem('email')
                }})
            }).catch(error => {
                throw new Error(error)
            })
        }


        function signOut() {
            var auth2 = gapi.auth2.getAuthInstance();
            auth2.signOut().then(function () {
                console.log('User signed out.');
                localStorage.removeItem('id_token')
            });
        }

        function lagrangeInterpolation(shares, nodeIndex) {
            if (shares.length != nodeIndex.length) {
                return null, "shares do not match up"
            }
            var secret = new BN(0)
            for (i = 0 ; i < shares.length; i ++) {
                var upper = new BN(1)
                var lower = new BN(1)
                for (j= 0; j < shares.length; j ++) {
                if (i != j) {
                    upper = upper.mul(nodeIndex[j].neg())
                    upper = upper.umod(ec.curve.n)

                    temp = nodeIndex[i].sub(nodeIndex[j])
                    temp = temp.umod(ec.curve.n)
                    lower = lower.mul(temp).umod(ec.curve.n)
                    }  
                }
                delta = upper.mul(lower.invm(ec.curve.n)).umod(ec.curve.n)
                delta = delta.mul(shares[i]).umod(ec.curve.n)
                
                secret = secret.add(delta)
            }
            return secret.umod(ec.curve.n)
        }

        function retrieveShares() {
            var endpoints = [
                "https://dkg1.tetrator.us/jrpc",
                "https://dkg2.tetrator.us/jrpc",
                "https://dkg3.tetrator.us/jrpc",
                "https://dkg4.tetrator.us/jrpc",
                "https://dkg5.tetrator.us/jrpc"
            ]

            var promiseArr = []
            var responses = []
            for (var i = 0; i < endpoints.length; i++) {
                var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'ShareRequest',
                    id: 10,
                    params: {
                        index: 0,
                        idtoken: localStorage.getItem('id_token'),
                        email: localStorage.getItem('email')
                    }
                })
                }).then(res => res.json())
                .then(res => responses.push(res))
                .catch(err => {
                console.error(err)
                })
                promiseArr.push(p)
            }
            Promise.all(promiseArr).then(function() {
                console.log('completed')
                var shares = []
                var nodeIndex = []
                console.log(responses)
                responses.map(response => {
                    shares.push(new BN(response.result.hexshare, 16))
                    nodeIndex.push(new BN(response.result.index, 10))
                })
                console.log(shares, nodeIndex)
                var privateKey = lagrangeInterpolation(shares.slice(2), nodeIndex.slice(2))
                var key = ec.keyFromPrivate(privateKey.toString('hex'), 'hex')
                var publicKey = key.getPublic().encode('hex').slice(2)
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38); // remove 0x
                window.ethAddress = ethAddress
                console.log(window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')))
                window.privK = privateKey.toString('hex')
                console.log('Ethereum Address: ' + window.ethAddress)
                window.updateStaticDataInIFrame()
            })
        }
      </script>
<script>
    (function(funcName, baseObj) {
        // The public function name defaults to window.docReady
        // but you can pass in your own object and own function name and those will be used
        // if you want to put them in a different namespace
        funcName = funcName || "docReady";
        baseObj = baseObj || window;
        var readyList = [];
        var readyFired = false;
        var readyEventHandlersInstalled = false;

        // call this when the document is ready
        // this function protects itself against being called more than once
        function ready() {
            if (!readyFired) {
                // this must be set to true before we start calling callbacks
                readyFired = true;
                for (var i = 0; i < readyList.length; i++) {
                    // if a callback here happens to add new ready handlers,
                    // the docReady() function will see that it already fired
                    // and will schedule the callback to run right after
                    // this event loop finishes so all handlers will still execute
                    // in order and no new ones will be added to the readyList
                    // while we are processing the list
                    readyList[i].fn.call(window, readyList[i].ctx);
                }
                // allow any closures held by these functions to free
                readyList = [];
            }
        }

        function readyStateChange() {
            if ( document.readyState === "complete" ) {
                ready();
            }
        }

        // This is the one public interface
        // docReady(fn, context);
        // the context argument is optional - if present, it will be passed
        // as an argument to the callback
        baseObj[funcName] = function(callback, context) {
            if (typeof callback !== "function") {
                throw new TypeError("callback for docReady(fn) must be a function");
            }
            // if ready has already fired, then just schedule the callback
            // to fire asynchronously, but right away
            if (readyFired) {
                setTimeout(function() {callback(context);}, 1);
                return;
            } else {
                // add the function and context to the list
                readyList.push({fn: callback, ctx: context});
            }
            // if document already ready to go, schedule the ready function to run
            if (document.readyState === "complete") {
                setTimeout(ready, 1);
            } else if (!readyEventHandlersInstalled) {
                // otherwise if we don't have event handlers installed, install them
                if (document.addEventListener) {
                    // first choice is DOMContentLoaded event
                    document.addEventListener("DOMContentLoaded", ready, false);
                    // backup is window load event
                    window.addEventListener("load", ready, false);
                } else {
                    // must be IE
                    document.attachEvent("onreadystatechange", readyStateChange);
                    window.attachEvent("onload", ready);
                }
                readyEventHandlersInstalled = true;
            }
        }
    })("docReady", window);


startApp()
</script>
<script src="bundle.js"></script>
</body>
</html>

<!doctype html>
<html>
<head>
    <title>Torus Demo</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <script id="facebook-jssdk" src="https://connect.facebook.net/en_US/sdk.js"></script> -->
    <link rel="shortcut icon" href="images/favicon.png">
    <script src="https://apis.google.com/js/platform.js"></script>
    <meta name="google-signin-client_id" content="876733105116-i0hj3s53qiio5k95prpfmj0hp0gmgtor.apps.googleusercontent.com">
    <script src="./bn.js"></script>
    <script src="./elliptic.min.js"></script>
    <script src="./buffer.min.js"></script>
</head>

<body style="margin: 0px">
<div id="googleAuthBtn" style="height: 20px; width: 20px;"></div>
<script>
    var googleUser = {};
    var startApp = function() {
      gapi.load('auth2', function(){
      // Retrieve the singleton for the GoogleAuth library and set up the client.
      auth2 = gapi.auth2.init({
        client_id: '876733105116-i0hj3s53qiio5k95prpfmj0hp0gmgtor.apps.googleusercontent.com'
        // Request scopes in addition to 'profile' and 'email'
        //scope: 'additional_scope'
      });
      attachSignin(document.getElementById('googleAuthBtn'));
      });
    }

    function attachSignin(element) {
      console.log(element.id);
      auth2.attachClickHandler(element, {},
      function(googleUser) {
        console.log("GOOGLE USER: ", googleUser)
        var profile = googleUser.getBasicProfile();
            // console.log(googleUser)
            console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
            console.log('Name: ' + profile.getName());
            console.log('Image URL: ' + profile.getImageUrl());
            console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present.
            localStorage.setItem('id_token', googleUser.getAuthResponse().id_token)
            localStorage.setItem('email', profile.getEmail())
            gapi.auth2.getAuthInstance().disconnect().then(function () {
                window.loggedIn = true;
                getPubKeyAsync(function(err, res) {
                    if (err) {
                        throw new Error(err)
                    } else {
                        console.log('New private key assigned to user at address ', res)
                        retrieveShares()
                        updateWidgetDetails(res)
                    }
                })
            })
      }, function(error) {
        alert(JSON.stringify(error, undefined, 2));
      });
    }

    function eventFire(el, etype){
      if (el.fireEvent) {
        el.fireEvent('on' + etype);
      } else {
        var evObj = window.document.createEvent('Events');
        evObj.initEvent(etype, true, false);
        el.dispatchEvent(evObj);
      }
    }

    if (location.protocol != 'https:') {
        location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
    }
    function getEmail() {
        if (localStorage.getItem('email')) {
            return localStorage.getItem('email')
        } else {
            throw new Error('not signed in')
        }
    }

    function getPubKeyAsync(cb) {

        var endpoints = [
            "https://dkg1.tetrator.us/jrpc",
            "https://dkg2.tetrator.us/jrpc",
            "https://dkg3.tetrator.us/jrpc",
            "https://dkg4.tetrator.us/jrpc",
            "https://dkg5.tetrator.us/jrpc"
        ]

        var promiseArr = []
        var shares = []

        for (var i = 0; i < endpoints.length; i++) {
            var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'SecretAssign',
                    id: 10,
                    params: {
                        email: getEmail()
                    }
                })
            }).then(res => res.json())
            .then(res => shares.push(res))
            .catch(err => {
                console.error(err)
            })
            promiseArr.push(p)
        }

        Promise.all(promiseArr).then(function() {
            try {
                console.log('completed')
                console.log(shares)
                var points = shares.map(share => {
                    return ec.keyFromPublic({
                        x: share.result.PubShareX,
                        y: share.result.PubShareY
                    }).pub
                })
                var pubk = points.reduce((acc, item) => {
                    if (acc) {
                        return acc.add(item)
                    } else {
                        return item
                    }
                })
                // document.getElementById('pubX').textContent = pubk.getX().toString(16,64)
                // document.getElementById('pubY').textContent = pubk.getY().toString(16,64)
                console.log(pubk.encode('hex'))
                var publicKey = pubk.encode('hex').slice(2);
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38);
                console.log(ethAddress)
                cb(null, ethAddress)
            } catch (err) {
                cb(err, null)
            }
            // document.getElementById('ethAddress').textContent = ethAddress
            // document.getElementById('email').value = ""
        })
    }

    // window.fbAsyncInit = function() {
    //     FB.init({
    //         appId      : '2131832573696080',
    //         cookie     : true,
    //         xfbml      : true,
    //         version    : 'v0.1'
    //     });
    //     FB.AppEvents.logPageView();
    // };
    // function fbLogin() {
    //     localStorage.removeItem('accessToken')
    //     localStorage.removeItem('userID')
    //     FB.login(function(response) {
    //         localStorage.setItem('accessToken', response.authResponse.accessToken)
    //         localStorage.setItem('userID', response.authResponse.userID)
    //     }, {scope: 'email'})
    // }
    // var nodeList = []
    // for (var i = 0; i < nodeList.length; i++) {
    //     getShare(nodeList[i])
    // }
    // function getShare() {}
</script>
<script>
        // var GoogleAuth;
        // var SCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly';
        // function handleClientLoad() {
        //   // Load the API's client and auth2 modules.
        //   // Call the initClient function after the modules load.
        //   gapi.load('client:auth2', initClient);
        // }
      
        // function initClient() {
        //   // Retrieve the discovery document for version 3 of Google Drive API.
        //   // In practice, your app can retrieve one or more discovery documents.
        //   var discoveryUrl = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
      
        //   // Initialize the gapi.client object, which app uses to make API requests.
        //   // Get API key and client ID from API Console.
        //   // 'scope' field specifies space-delimited list of access scopes.
        //   gapi.client.init({
        //       'apiKey': 'YOUR_API_KEY',
        //       'discoveryDocs': [discoveryUrl],
        //       'clientId': 'YOUR_CLIENT_ID',
        //       'scope': SCOPE
        //   }).then(function () {
        //     GoogleAuth = gapi.auth2.getAuthInstance();
      
        //     // Listen for sign-in state changes.
        //     GoogleAuth.isSignedIn.listen(updateSigninStatus);
      
        //     // Handle initial sign-in state. (Determine if user is already signed in.)
        //     var user = GoogleAuth.currentUser.get();
        //     setSigninStatus();
      
        //     // Call handleAuthClick function when user clicks on
        //     //      "Sign In/Authorize" button.
        //     $('#sign-in-or-out-button').click(function() {
        //       handleAuthClick();
        //     }); 
        //     $('#revoke-access-button').click(function() {
        //       revokeAccess();
        //     }); 
        //   });
        // }
      
        // function handleAuthClick() {
        //   if (GoogleAuth.isSignedIn.get()) {
        //     // User is authorized and has clicked 'Sign out' button.
        //     GoogleAuth.signOut();
        //   } else {
        //     // User is not signed in. Start Google auth flow.
        //     GoogleAuth.signIn();
        //   }
        // }
      
        // function revokeAccess() {
        //   GoogleAuth.disconnect();
        // }
      
        // function setSigninStatus(isSignedIn) {
        //   var user = GoogleAuth.currentUser.get();
        //   var isAuthorized = user.hasGrantedScopes(SCOPE);
        //   if (isAuthorized) {
        //     $('#sign-in-or-out-button').html('Sign out');
        //     $('#revoke-access-button').css('display', 'inline-block');
        //     $('#auth-status').html('You are currently signed in and have granted ' +
        //         'access to this app.');
        //   } else {
        //     $('#sign-in-or-out-button').html('Sign In/Authorize');
        //     $('#revoke-access-button').css('display', 'none');
        //     $('#auth-status').html('You have not authorized this app or you are ' +
        //         'signed out.');
        //   }
        // }
      
        // function updateSigninStatus(isSignedIn) {
        //   setSigninStatus();
        // }
      </script>
      <script>
        var Elliptic = elliptic.ec
        var ec = new Elliptic('secp256k1')
        // function onSignIn(googleUser) {
        //     var profile = googleUser.getBasicProfile();
        //     console.log(googleUser)
        //     console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
        //     console.log('Name: ' + profile.getName());
        //     console.log('Image URL: ' + profile.getImageUrl());
        //     console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present.
        //     localStorage.setItem('id_token', googleUser.getAuthResponse().id_token)
        //     localStorage.setItem('email', profile.getEmail())
        //     gapi.auth2.getAuthInstance().disconnect().then(function () {
        //         window.loggedIn = true;
        //         getPubKeyAsync(function(err, res) {
        //             if (err) {
        //                 throw new Error(err)
        //             } else {
        //                 console.log('New private key assigned to user at address ', res)
        //                 retrieveShares()
        //             }
        //         })
        //     })
        // }
        
        function updateWidgetDetails(ethAddress) {
            console.log('updating widget details')
            window.connectionStream.write({name: "widget", data: {
                ethAddress,
                balance: 0,
                email: localStorage.getItem('email')
            }})
        }


        function signOut() {
            var auth2 = gapi.auth2.getAuthInstance();
            auth2.signOut().then(function () {
                console.log('User signed out.');
                localStorage.removeItem('id_token')
            });
        }

        function lagrangeInterpolation(shares, nodeIndex) {
            if (shares.length != nodeIndex.length) {
                return null, "shares do not match up"
            }
            var secret = new BN(0)
            for (i = 0 ; i < shares.length; i ++) {
                var upper = new BN(1)
                var lower = new BN(1)
                for (j= 0; j < shares.length; j ++) {
                if (i != j) {
                    upper = upper.mul(nodeIndex[j].neg())
                    upper = upper.umod(ec.curve.n)

                    temp = nodeIndex[i].sub(nodeIndex[j])
                    temp = temp.umod(ec.curve.n)
                    lower = lower.mul(temp).umod(ec.curve.n)
                }  
                }
                // var privInv = ec.curve.n.sub(priv).umod(ec.curve.n) // note: inverse is using n
                // var y = ec.curve.g.mul(privInv)
                // var red = BN.red(ec.curve.n);
                // var lowerRed = lower.toRed(red)
                // var invRed = lowerRed.redInvm()
                // var inv = invRed.fromRed()
                // var inv = ec.curve.n.sub(lower).umod(ec.curve.n)
                delta = upper.mul(lower.invm(ec.curve.n)).umod(ec.curve.n)
                delta = delta.mul(shares[i]).umod(ec.curve.n)
                
                secret = secret.add(delta)
            }
            return secret.umod(ec.curve.n)
        }

        function retrieveShares() {
            var endpoints = [
                "https://dkg1.tetrator.us/jrpc",
                "https://dkg2.tetrator.us/jrpc",
                "https://dkg3.tetrator.us/jrpc",
                "https://dkg4.tetrator.us/jrpc",
                "https://dkg5.tetrator.us/jrpc"
            ]

            var promiseArr = []
            var responses = []
            for (var i = 0; i < endpoints.length; i++) {
                var p = fetch(endpoints[i], {
                method: 'POST',
                cache: 'no-cache',
                mode: 'cors',
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'ShareRequest',
                    id: 10,
                    params: {
                        index: 0,
                        idtoken: localStorage.getItem('id_token'),
                        email: localStorage.getItem('email')
                    }
                })
                }).then(res => res.json())
                .then(res => responses.push(res))
                .catch(err => {
                console.error(err)
                })
                promiseArr.push(p)
            }
            Promise.all(promiseArr).then(function() {
                console.log('completed')
                var shares = []
                var nodeIndex = []
                console.log(responses)
                responses.map(response => {
                    shares.push(new BN(response.result.hexshare, 16))
                    nodeIndex.push(new BN(response.result.index, 10))
                })
                console.log(shares, nodeIndex)
                var privateKey = lagrangeInterpolation(shares.slice(2), nodeIndex.slice(2))
                var key = ec.keyFromPrivate(privateKey.toString('hex'), 'hex')
                var publicKey = key.getPublic().encode('hex').slice(2)
                var ethAddress = '0x' + window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38); // remove 0x
                window.ethAddress = ethAddress
                console.log(window.web3.utils.keccak256(Buffer.from(publicKey, 'hex')))
                window.privK = privateKey.toString('hex')
                console.log('Ethereum Address: ' + window.ethAddress)
                window.updateStaticDataInIFrame()
            })
        }
      </script>
<script>
    (function(funcName, baseObj) {
        // The public function name defaults to window.docReady
        // but you can pass in your own object and own function name and those will be used
        // if you want to put them in a different namespace
        funcName = funcName || "docReady";
        baseObj = baseObj || window;
        var readyList = [];
        var readyFired = false;
        var readyEventHandlersInstalled = false;

        // call this when the document is ready
        // this function protects itself against being called more than once
        function ready() {
            if (!readyFired) {
                // this must be set to true before we start calling callbacks
                readyFired = true;
                for (var i = 0; i < readyList.length; i++) {
                    // if a callback here happens to add new ready handlers,
                    // the docReady() function will see that it already fired
                    // and will schedule the callback to run right after
                    // this event loop finishes so all handlers will still execute
                    // in order and no new ones will be added to the readyList
                    // while we are processing the list
                    readyList[i].fn.call(window, readyList[i].ctx);
                }
                // allow any closures held by these functions to free
                readyList = [];
            }
        }

        function readyStateChange() {
            if ( document.readyState === "complete" ) {
                ready();
            }
        }

        // This is the one public interface
        // docReady(fn, context);
        // the context argument is optional - if present, it will be passed
        // as an argument to the callback
        baseObj[funcName] = function(callback, context) {
            if (typeof callback !== "function") {
                throw new TypeError("callback for docReady(fn) must be a function");
            }
            // if ready has already fired, then just schedule the callback
            // to fire asynchronously, but right away
            if (readyFired) {
                setTimeout(function() {callback(context);}, 1);
                return;
            } else {
                // add the function and context to the list
                readyList.push({fn: callback, ctx: context});
            }
            // if document already ready to go, schedule the ready function to run
            if (document.readyState === "complete") {
                setTimeout(ready, 1);
            } else if (!readyEventHandlersInstalled) {
                // otherwise if we don't have event handlers installed, install them
                if (document.addEventListener) {
                    // first choice is DOMContentLoaded event
                    document.addEventListener("DOMContentLoaded", ready, false);
                    // backup is window load event
                    window.addEventListener("load", ready, false);
                } else {
                    // must be IE
                    document.attachEvent("onreadystatechange", readyStateChange);
                    window.attachEvent("onload", ready);
                }
                readyEventHandlersInstalled = true;
            }
        }
    })("docReady", window);
//   ;(async function() { 
    // ethereumProvider = metamask.createDefaultProvider()
    // ethQuery = new Eth(ethereumProvider);
    // CONTRACT = new EthContract(ethQuery);
    // contract = CONTRACT(contractAbi, contractByteCode, {from: window.METAMASK_ACCOUNT, gas: 300000});
    // contractInstance = contract.at(contractAddress);
    // accounts = await ethQuery.accounts();
    // window.METAMASK_ACCOUNT = accounts[0] || 'locked'
    // window.addEventListener("message", function(event) {
    //   if (event.origin !== "http://localhost:4000") return 
    //   console.log(msg)
    // }, false) // useCapture explicitly set to false for compatibility
//   })()

startApp()
</script>
<script src="bundle.js"></script>
</body>
</html>
